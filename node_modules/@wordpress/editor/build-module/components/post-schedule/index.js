import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { createElement } from "@wordpress/element";

/**
 * WordPress dependencies
 */
import { __experimentalGetSettings } from '@wordpress/date';
import { useDispatch, useSelect } from '@wordpress/data';
import { DateTimePicker } from '@wordpress/components';
import { useRef, useState, useMemo } from '@wordpress/element';
import { store as coreStore } from '@wordpress/core-data';
/**
 * Internal dependencies
 */

import { store as editorStore } from '../../store';

function getDayOfTheMonth() {
  var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
  var firstDay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var d = new Date(date);
  return new Date(d.getFullYear(), d.getMonth() + (firstDay ? 0 : 1), firstDay ? 1 : 0).toISOString();
}

export default function PostSchedule() {
  var _useSelect = useSelect(function (select) {
    return {
      postDate: select(editorStore).getEditedPostAttribute('date'),
      postType: select(editorStore).getCurrentPostType()
    };
  }, []),
      postDate = _useSelect.postDate,
      postType = _useSelect.postType;

  var _useDispatch = useDispatch(editorStore),
      editPost = _useDispatch.editPost;

  var onUpdateDate = function onUpdateDate(date) {
    return editPost({
      date: date
    });
  };

  var _useState = useState(getDayOfTheMonth(postDate)),
      _useState2 = _slicedToArray(_useState, 2),
      previewedMonth = _useState2[0],
      setPreviewedMonth = _useState2[1]; // Pick up published and schduled site posts.


  var eventsByPostType = useSelect(function (select) {
    return select(coreStore).getEntityRecords('postType', postType, {
      status: 'publish,future',
      after: getDayOfTheMonth(previewedMonth),
      before: getDayOfTheMonth(previewedMonth, false),
      exclude: [select(editorStore).getCurrentPostId()]
    });
  }, [previewedMonth, postType]);
  var events = useMemo(function () {
    return (eventsByPostType || []).map(function (_ref) {
      var title = _ref.title,
          type = _ref.type,
          eventDate = _ref.date;
      return {
        title: title === null || title === void 0 ? void 0 : title.rendered,
        type: type,
        date: new Date(eventDate)
      };
    });
  }, [eventsByPostType]);
  var ref = useRef();

  var settings = __experimentalGetSettings(); // To know if the current timezone is a 12 hour time with look for "a" in the time format
  // We also make sure this a is not escaped by a "/"


  var is12HourTime = /a(?!\\)/i.test(settings.formats.time.toLowerCase() // Test only the lower case a
  .replace(/\\\\/g, '') // Replace "//" with empty strings
  .split('').reverse().join('') // Reverse the string and test for "a" not followed by a slash
  );

  function onChange(newDate) {
    onUpdateDate(newDate);
    var ownerDocument = ref.current.ownerDocument;
    ownerDocument.activeElement.blur();
  }

  return createElement(DateTimePicker, {
    ref: ref,
    currentDate: postDate,
    onChange: onChange,
    is12Hour: is12HourTime,
    events: events,
    onMonthPreviewed: setPreviewedMonth
  });
}
//# sourceMappingURL=index.js.map