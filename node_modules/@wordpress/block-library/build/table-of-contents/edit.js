"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = TableOfContentsEdit;

var _element = require("@wordpress/element");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _lodash = require("lodash");

var _blockEditor = require("@wordpress/block-editor");

var _blocks = require("@wordpress/blocks");

var _components = require("@wordpress/components");

var _data = require("@wordpress/data");

var _editor = require("@wordpress/editor");

var _i18n = require("@wordpress/i18n");

var _list = _interopRequireDefault(require("./list"));

var _utils = require("./utils");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Table of Contents block edit component.
 *
 * @param {Object}                       props            The props.
 * @param {Object}                       props.attributes The block attributes.
 * @param {boolean}                      props.attributes.onlyIncludeCurrentPage
 * Whether to only include headings from the current page (if the post is
 * paginated).
 * @param {string}                       props.clientId
 * @param {(attributes: Object) => void} props.setAttributes
 *
 * @return {WPComponent} The component.
 */
function TableOfContentsEdit(_ref) {
  var onlyIncludeCurrentPage = _ref.attributes.onlyIncludeCurrentPage,
      clientId = _ref.clientId,
      setAttributes = _ref.setAttributes;
  var blockProps = (0, _blockEditor.useBlockProps)(); // Local state; not saved to block attributes. The saved block is dynamic and uses PHP to generate its content.

  var _useState = (0, _element.useState)([]),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      headings = _useState2[0],
      setHeadings = _useState2[1];

  var _useState3 = (0, _element.useState)([]),
      _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
      headingTree = _useState4[0],
      setHeadingTree = _useState4[1];

  var _useSelect = (0, _data.useSelect)(function (select) {
    return {
      listBlockExists: !!select(_blocks.store).getBlockType('core/list'),
      postContent: select(_editor.store).getEditedPostContent()
    };
  }, []),
      listBlockExists = _useSelect.listBlockExists,
      postContent = _useSelect.postContent; // The page this block would be part of on the front-end. For performance
  // reasons, this is only calculated when onlyIncludeCurrentPage is true.


  var pageIndex = (0, _data.useSelect)(function (select) {
    if (!onlyIncludeCurrentPage) {
      return null;
    }

    var _select = select(_blockEditor.store),
        getBlockAttributes = _select.getBlockAttributes,
        getBlockIndex = _select.getBlockIndex,
        getBlockName = _select.getBlockName,
        getBlockOrder = _select.getBlockOrder;

    var blockIndex = getBlockIndex(clientId);
    var blockOrder = getBlockOrder(); // Calculate which page the block will appear in on the front-end by
    // counting how many <!--nextpage--> tags precede it.
    // Unfortunately, this implementation only accounts for Page Break and
    // Classic blocks, so if there are any <!--nextpage--> tags in any
    // other block, they won't be counted. This will result in the table
    // of contents showing headings from the wrong page if
    // onlyIncludeCurrentPage === true. Thankfully, this issue only
    // affects the editor implementation.

    var page = 1;

    for (var i = 0; i < blockIndex; i++) {
      var blockName = getBlockName(blockOrder[i]);

      if (blockName === 'core/nextpage') {
        page++;
      } else if (blockName === 'core/freeform') {
        var _getBlockAttributes$c;

        // Count the page breaks inside the Classic block.
        var pageBreaks = (_getBlockAttributes$c = getBlockAttributes(blockOrder[i]).content) === null || _getBlockAttributes$c === void 0 ? void 0 : _getBlockAttributes$c.match(/<!--nextpage-->/g);

        if (pageBreaks !== null && pageBreaks !== undefined) {
          page += pageBreaks.length;
        }
      }
    }

    return page;
  }, [clientId, onlyIncludeCurrentPage]);
  (0, _element.useEffect)(function () {
    var latestHeadings;

    if (onlyIncludeCurrentPage) {
      var pagesOfContent = postContent.split('<!--nextpage-->');
      latestHeadings = (0, _utils.getHeadingsFromContent)(pagesOfContent[pageIndex - 1]);
    } else {
      latestHeadings = (0, _utils.getHeadingsFromContent)(postContent);
    }

    if (!(0, _lodash.isEqual)(headings, latestHeadings)) {
      setHeadings(latestHeadings);
      setHeadingTree((0, _utils.linearToNestedHeadingList)(latestHeadings));
    }
  }, [pageIndex, postContent, onlyIncludeCurrentPage]);

  var _useDispatch = (0, _data.useDispatch)(_blockEditor.store),
      replaceBlocks = _useDispatch.replaceBlocks;

  var toolbarControls = listBlockExists && (0, _element.createElement)(_blockEditor.BlockControls, null, (0, _element.createElement)(_components.ToolbarGroup, null, (0, _element.createElement)(_components.ToolbarButton, {
    onClick: function onClick() {
      return replaceBlocks(clientId, (0, _blocks.createBlock)('core/list', {
        values: (0, _element.renderToString)((0, _element.createElement)(_list.default, {
          nestedHeadingList: headingTree
        }))
      }));
    }
  }, (0, _i18n.__)('Convert to static list'))));
  var inspectorControls = (0, _element.createElement)(_blockEditor.InspectorControls, null, (0, _element.createElement)(_components.PanelBody, {
    title: (0, _i18n.__)('Table of Contents settings')
  }, (0, _element.createElement)(_components.ToggleControl, {
    label: (0, _i18n.__)('Only include current page'),
    checked: onlyIncludeCurrentPage,
    onChange: function onChange(value) {
      return setAttributes({
        onlyIncludeCurrentPage: value
      });
    },
    help: onlyIncludeCurrentPage ? (0, _i18n.__)('Only including headings from the current page (if the post is paginated).') : (0, _i18n.__)('Toggle to only include headings from the current page (if the post is paginated).')
  }))); // If there are no headings or the only heading is empty.
  // Note that the toolbar controls are intentionally omitted since the
  // "Convert to static list" option is useless to the placeholder state.

  if (headings.length === 0) {
    return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)("div", blockProps, (0, _element.createElement)(_components.Placeholder, {
      icon: (0, _element.createElement)(_blockEditor.BlockIcon, {
        icon: "list-view"
      }),
      label: "Table of Contents",
      instructions: (0, _i18n.__)('Start adding Heading blocks to create a table of contents. Headings with HTML anchors will be linked here.')
    })), inspectorControls);
  }

  return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)("nav", blockProps, (0, _element.createElement)("ul", null, (0, _element.createElement)(_list.default, {
    nestedHeadingList: headingTree
  }))), toolbarControls, inspectorControls);
}
//# sourceMappingURL=edit.js.map