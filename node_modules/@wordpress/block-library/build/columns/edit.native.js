"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _reactNative = require("react-native");

var _lodash = require("lodash");

var _i18n = require("@wordpress/i18n");

var _components = require("@wordpress/components");

var _blockEditor = require("@wordpress/block-editor");

var _data = require("@wordpress/data");

var _compose = require("@wordpress/compose");

var _blocks = require("@wordpress/blocks");

var _icons = require("@wordpress/icons");

var _variations = _interopRequireDefault(require("./variations"));

var _editor = _interopRequireDefault(require("./editor.scss"));

var _utils = require("./utils");

var _columnCalculations = require("./columnCalculations.native");

var _columnPreview = _interopRequireDefault(require("../column/column-preview"));

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Allowed blocks constant is passed to InnerBlocks precisely as specified here.
 * The contents of the array should never change.
 * The array should contain the name of each block that is allowed.
 * In columns block, the only block we allow is 'core/column'.
 *
 * @constant
 * @type {string[]}
 */
var ALLOWED_BLOCKS = ['core/column'];
/**
 * Number of columns to assume for template in case the user opts to skip
 * template option selection.
 *
 * @type {number}
 */

var DEFAULT_COLUMNS_NUM = 2;
/**
 * Minimum number of columns in a row
 *
 * @type {number}
 */

var MIN_COLUMNS_NUM = 1;
var isWider = _components.alignmentHelpers.isWider,
    isFullWidth = _components.alignmentHelpers.isFullWidth;

function ColumnsEditContainer(_ref) {
  var attributes = _ref.attributes,
      updateAlignment = _ref.updateAlignment,
      updateColumns = _ref.updateColumns,
      columnCount = _ref.columnCount,
      isSelected = _ref.isSelected,
      onDeleteBlock = _ref.onDeleteBlock,
      innerWidths = _ref.innerWidths,
      updateInnerColumnWidth = _ref.updateInnerColumnWidth,
      editorSidebarOpened = _ref.editorSidebarOpened;

  var _useResizeObserver = (0, _compose.useResizeObserver)(),
      _useResizeObserver2 = (0, _slicedToArray2.default)(_useResizeObserver, 2),
      resizeListener = _useResizeObserver2[0],
      sizes = _useResizeObserver2[1];

  var _useState = (0, _element.useState)(MIN_COLUMNS_NUM),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      columnsInRow = _useState2[0],
      setColumnsInRow = _useState2[1];

  var screenWidth = Math.floor(_reactNative.Dimensions.get('window').width);
  var globalStyles = (0, _element.useContext)(_components.GlobalStylesContext);
  var verticalAlignment = attributes.verticalAlignment,
      align = attributes.align;

  var _ref2 = sizes || {},
      width = _ref2.width;

  (0, _element.useEffect)(function () {
    if (columnCount === 0) {
      var newColumnCount = columnCount || DEFAULT_COLUMNS_NUM;
      updateColumns(columnCount, newColumnCount);
    }
  }, []);
  (0, _element.useEffect)(function () {
    if (width) {
      if ((0, _columnCalculations.getColumnsInRow)(width, columnCount) !== columnsInRow) {
        setColumnsInRow((0, _columnCalculations.getColumnsInRow)(width, columnCount));
      }
    }
  }, [width, columnCount]);

  var renderAppender = function renderAppender() {
    var isEqualWidth = width === screenWidth;

    if (isSelected) {
      return (0, _element.createElement)(_reactNative.View, {
        style: (isWider(screenWidth, 'mobile') || isEqualWidth) && _editor.default.columnAppender
      }, (0, _element.createElement)(_blockEditor.InnerBlocks.ButtonBlockAppender, {
        onAddBlock: onAddBlock
      }));
    }

    return null;
  };

  var contentWidths = (0, _element.useMemo)(function () {
    return (0, _columnCalculations.getContentWidths)(columnsInRow, width, columnCount, innerWidths, globalStyles);
  }, [width, columnsInRow, columnCount, innerWidths, globalStyles]);
  var onAddBlock = (0, _element.useCallback)(function () {
    updateColumns(columnCount, columnCount + 1);
  }, [columnCount]);

  var onChangeWidth = function onChangeWidth(nextWidth, valueUnit, columnId) {
    var widthWithUnit = (0, _utils.getWidthWithUnit)(nextWidth, valueUnit);
    updateInnerColumnWidth(widthWithUnit, columnId);
  };

  var onChangeUnit = function onChangeUnit(nextUnit, index, columnId) {
    var widthWithoutUnit = parseFloat((0, _utils.getWidths)(innerWidths)[index]);
    var widthWithUnit = (0, _utils.getWidthWithUnit)(widthWithoutUnit, nextUnit);
    updateInnerColumnWidth(widthWithUnit, columnId);
  };

  var _onChange = function onChange(nextWidth, valueUnit, columnId) {
    if ((0, _utils.isPercentageUnit)(valueUnit) || !valueUnit) {
      return;
    }

    onChangeWidth(nextWidth, valueUnit, columnId);
  };

  var getColumnsSliders = (0, _element.useMemo)(function () {
    if (!editorSidebarOpened || !isSelected) {
      return null;
    }

    return innerWidths.map(function (column, index) {
      var _ref3 = (0, _components.getValueAndUnit)(column.attributes.width) || {},
          _ref3$valueUnit = _ref3.valueUnit,
          valueUnit = _ref3$valueUnit === void 0 ? '%' : _ref3$valueUnit;

      return (0, _element.createElement)(_components.UnitControl, {
        label: "Column ".concat(index + 1),
        settingLabel: "Width",
        key: "".concat(column.clientId, "-").concat((0, _utils.getWidths)(innerWidths).length),
        min: 1,
        max: (0, _utils.isPercentageUnit)(valueUnit) || !valueUnit ? 100 : undefined,
        decimalNum: 1,
        value: (0, _utils.getWidths)(innerWidths)[index],
        onChange: function onChange(nextWidth) {
          _onChange(nextWidth, valueUnit, column.clientId);
        },
        onUnitChange: function onUnitChange(nextUnit) {
          return onChangeUnit(nextUnit, index, column.clientId);
        },
        onComplete: function onComplete(nextWidth) {
          onChangeWidth(nextWidth, valueUnit, column.clientId);
        },
        unit: valueUnit,
        units: _utils.CSS_UNITS,
        preview: (0, _element.createElement)(_columnPreview.default, {
          columnWidths: (0, _utils.getWidths)(innerWidths, false),
          selectedColumnIndex: index
        })
      });
    });
  }, [editorSidebarOpened, isSelected, innerWidths]);
  var onChangeColumnsNum = (0, _element.useCallback)(function (value) {
    updateColumns(columnCount, value);
  }, [columnCount]);
  return (0, _element.createElement)(_element.Fragment, null, isSelected && (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_blockEditor.InspectorControls, null, (0, _element.createElement)(_components.PanelBody, {
    title: (0, _i18n.__)('Columns Settings')
  }, (0, _element.createElement)(_components.RangeControl, {
    label: (0, _i18n.__)('Number of columns'),
    icon: _icons.columns,
    value: columnCount,
    onChange: onChangeColumnsNum,
    min: MIN_COLUMNS_NUM,
    max: columnCount + 1,
    type: "stepper"
  }), getColumnsSliders), (0, _element.createElement)(_components.PanelBody, null, (0, _element.createElement)(_components.FooterMessageControl, {
    label: (0, _i18n.__)('Note: Column layout may vary between themes and screen sizes')
  }))), (0, _element.createElement)(_blockEditor.BlockControls, null, (0, _element.createElement)(_blockEditor.BlockVerticalAlignmentToolbar, {
    onChange: updateAlignment,
    value: verticalAlignment
  }))), (0, _element.createElement)(_reactNative.View, {
    style: isSelected && _editor.default.innerBlocksSelected
  }, resizeListener, width && (0, _element.createElement)(_blockEditor.InnerBlocks, {
    renderAppender: renderAppender,
    orientation: columnsInRow > 1 ? 'horizontal' : undefined,
    horizontal: true,
    allowedBlocks: ALLOWED_BLOCKS,
    contentResizeMode: "stretch",
    onAddBlock: onAddBlock,
    onDeleteBlock: columnCount === 1 ? onDeleteBlock : undefined,
    blockWidth: width,
    contentStyle: contentWidths,
    parentWidth: isFullWidth(align) && columnCount === 0 ? screenWidth : (0, _columnCalculations.calculateContainerWidth)(width, columnsInRow)
  })));
}

var ColumnsEditContainerWrapper = (0, _data.withDispatch)(function (dispatch, ownProps, registry) {
  return {
    /**
     * Update all child Column blocks with a new vertical alignment setting
     * based on whatever alignment is passed in. This allows change to parent
     * to overide anything set on a individual column basis.
     *
     * @param {string} verticalAlignment the vertical alignment setting
     */
    updateAlignment: function updateAlignment(verticalAlignment) {
      var clientId = ownProps.clientId,
          setAttributes = ownProps.setAttributes;

      var _dispatch = dispatch(_blockEditor.store),
          updateBlockAttributes = _dispatch.updateBlockAttributes;

      var _registry$select = registry.select(_blockEditor.store),
          getBlockOrder = _registry$select.getBlockOrder; // Update own alignment.


      setAttributes({
        verticalAlignment: verticalAlignment
      }); // Update all child Column Blocks to match

      var innerBlockClientIds = getBlockOrder(clientId);
      innerBlockClientIds.forEach(function (innerBlockClientId) {
        updateBlockAttributes(innerBlockClientId, {
          verticalAlignment: verticalAlignment
        });
      });
    },
    updateInnerColumnWidth: function updateInnerColumnWidth(value, columnId) {
      var _dispatch2 = dispatch(_blockEditor.store),
          updateBlockAttributes = _dispatch2.updateBlockAttributes;

      updateBlockAttributes(columnId, {
        width: value
      });
    },
    updateBlockSettings: function updateBlockSettings(settings) {
      var clientId = ownProps.clientId;

      var _dispatch3 = dispatch(_blockEditor.store),
          updateBlockListSettings = _dispatch3.updateBlockListSettings;

      updateBlockListSettings(clientId, settings);
    },

    /**
     * Updates the column columnCount, including necessary revisions to child Column
     * blocks to grant required or redistribute available space.
     *
     * @param {number} previousColumns Previous column columnCount.
     * @param {number} newColumns      New column columnCount.
     */
    updateColumns: function updateColumns(previousColumns, newColumns) {
      var clientId = ownProps.clientId;

      var _dispatch4 = dispatch(_blockEditor.store),
          replaceInnerBlocks = _dispatch4.replaceInnerBlocks;

      var _registry$select2 = registry.select(_blockEditor.store),
          getBlocks = _registry$select2.getBlocks,
          getBlockAttributes = _registry$select2.getBlockAttributes;

      var innerBlocks = getBlocks(clientId);
      var hasExplicitWidths = (0, _utils.hasExplicitPercentColumnWidths)(innerBlocks); // Redistribute available width for existing inner blocks.

      var isAddingColumn = newColumns > previousColumns; // Get verticalAlignment from Columns block to set the same to new Column

      var _ref4 = getBlockAttributes(clientId) || {},
          verticalAlignment = _ref4.verticalAlignment;

      if (isAddingColumn && hasExplicitWidths) {
        // If adding a new column, assign width to the new column equal to
        // as if it were `1 / columns` of the total available space.
        var newColumnWidth = (0, _utils.toWidthPrecision)(100 / newColumns); // Redistribute in consideration of pending block insertion as
        // constraining the available working width.

        var widths = (0, _utils.getRedistributedColumnWidths)(innerBlocks, 100 - newColumnWidth);
        innerBlocks = [].concat((0, _toConsumableArray2.default)((0, _utils.getMappedColumnWidths)(innerBlocks, widths)), (0, _toConsumableArray2.default)((0, _lodash.times)(newColumns - previousColumns, function () {
          return (0, _blocks.createBlock)('core/column', {
            width: newColumnWidth,
            verticalAlignment: verticalAlignment
          });
        })));
      } else if (isAddingColumn) {
        innerBlocks = [].concat((0, _toConsumableArray2.default)(innerBlocks), (0, _toConsumableArray2.default)((0, _lodash.times)(newColumns - previousColumns, function () {
          return (0, _blocks.createBlock)('core/column', {
            verticalAlignment: verticalAlignment
          });
        })));
      } else {
        // The removed column will be the last of the inner blocks.
        innerBlocks = (0, _lodash.dropRight)(innerBlocks, previousColumns - newColumns);

        if (hasExplicitWidths) {
          // Redistribute as if block is already removed.
          var _widths = (0, _utils.getRedistributedColumnWidths)(innerBlocks, 100);

          innerBlocks = (0, _utils.getMappedColumnWidths)(innerBlocks, _widths);
        }
      }

      replaceInnerBlocks(clientId, innerBlocks);
    },
    onAddNextColumn: function onAddNextColumn() {
      var clientId = ownProps.clientId;

      var _dispatch5 = dispatch(_blockEditor.store),
          replaceInnerBlocks = _dispatch5.replaceInnerBlocks,
          selectBlock = _dispatch5.selectBlock;

      var _registry$select3 = registry.select(_blockEditor.store),
          getBlocks = _registry$select3.getBlocks,
          getBlockAttributes = _registry$select3.getBlockAttributes; // Get verticalAlignment from Columns block to set the same to new Column


      var _getBlockAttributes = getBlockAttributes(clientId),
          verticalAlignment = _getBlockAttributes.verticalAlignment;

      var innerBlocks = getBlocks(clientId);
      var insertedBlock = (0, _blocks.createBlock)('core/column', {
        verticalAlignment: verticalAlignment
      });
      replaceInnerBlocks(clientId, [].concat((0, _toConsumableArray2.default)(innerBlocks), [insertedBlock]), true);
      selectBlock(insertedBlock.clientId);
    },
    onDeleteBlock: function onDeleteBlock() {
      var clientId = ownProps.clientId;

      var _dispatch6 = dispatch(_blockEditor.store),
          removeBlock = _dispatch6.removeBlock;

      removeBlock(clientId);
    }
  };
})((0, _element.memo)(ColumnsEditContainer));

var ColumnsEdit = function ColumnsEdit(props) {
  var clientId = props.clientId,
      isSelected = props.isSelected;

  var _useSelect = (0, _data.useSelect)(function (select) {
    var _getBlockAttributes2;

    var _select = select(_blockEditor.store),
        getBlockCount = _select.getBlockCount,
        getBlocks = _select.getBlocks,
        getBlockParents = _select.getBlockParents,
        getBlockAttributes = _select.getBlockAttributes;

    var _select2 = select('core/edit-post'),
        isEditorSidebarOpened = _select2.isEditorSidebarOpened;

    var innerBlocks = getBlocks(clientId);
    var isContentEmpty = (0, _lodash.map)(innerBlocks, function (innerBlock) {
      return innerBlock.innerBlocks.length;
    });
    var innerColumnsWidths = innerBlocks.map(function (inn) {
      return {
        clientId: inn.clientId,
        attributes: {
          width: inn.attributes.width
        }
      };
    });
    var parents = getBlockParents(clientId, true);
    return {
      columnCount: getBlockCount(clientId),
      isDefaultColumns: !(0, _lodash.compact)(isContentEmpty).length,
      innerWidths: innerColumnsWidths,
      hasParents: !!parents.length,
      parentBlockAlignment: (_getBlockAttributes2 = getBlockAttributes(parents[0])) === null || _getBlockAttributes2 === void 0 ? void 0 : _getBlockAttributes2.align,
      editorSidebarOpened: isSelected && isEditorSidebarOpened()
    };
  }, [clientId, isSelected]),
      columnCount = _useSelect.columnCount,
      isDefaultColumns = _useSelect.isDefaultColumns,
      _useSelect$innerWidth = _useSelect.innerWidths,
      innerWidths = _useSelect$innerWidth === void 0 ? [] : _useSelect$innerWidth,
      hasParents = _useSelect.hasParents,
      parentBlockAlignment = _useSelect.parentBlockAlignment,
      editorSidebarOpened = _useSelect.editorSidebarOpened;

  var memoizedInnerWidths = (0, _element.useMemo)(function () {
    return innerWidths;
  }, [// The JSON.stringify is used because innerWidth is always a new reference.
  // The innerBlocks is a new reference after each attribute change of any nested block.
  JSON.stringify(innerWidths)]);

  var _useState3 = (0, _element.useState)(false),
      _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
      isVisible = _useState4[0],
      setIsVisible = _useState4[1];

  (0, _element.useEffect)(function () {
    if (isSelected && isDefaultColumns) {
      (0, _lodash.delay)(function () {
        return setIsVisible(true);
      }, 100);
    }
  }, []);
  var onClose = (0, _element.useCallback)(function () {
    setIsVisible(false);
  }, []);
  return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(ColumnsEditContainerWrapper, (0, _extends2.default)({
    columnCount: columnCount,
    innerWidths: memoizedInnerWidths,
    hasParents: hasParents,
    parentBlockAlignment: parentBlockAlignment,
    editorSidebarOpened: editorSidebarOpened
  }, props)), (0, _element.createElement)(_blockEditor.BlockVariationPicker, {
    variations: _variations.default,
    onClose: onClose,
    clientId: clientId,
    isVisible: isVisible
  }));
};

var _default = ColumnsEdit;
exports.default = _default;
//# sourceMappingURL=edit.native.js.map