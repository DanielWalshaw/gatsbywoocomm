import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { createElement, Fragment } from "@wordpress/element";

/**
 * External dependencies
 */
import { isEqual } from 'lodash';
/**
 * WordPress dependencies
 */

import { BlockControls, BlockIcon, InspectorControls, store as blockEditorStore, useBlockProps } from '@wordpress/block-editor';
import { createBlock, store as blocksStore } from '@wordpress/blocks';
import { PanelBody, Placeholder, ToggleControl, ToolbarButton, ToolbarGroup } from '@wordpress/components';
import { useDispatch, useSelect } from '@wordpress/data';
import { store as editorStore } from '@wordpress/editor';
import { renderToString, useEffect, useState } from '@wordpress/element';
import { __ } from '@wordpress/i18n';
/**
 * Internal dependencies
 */

import TableOfContentsList from './list';
import { getHeadingsFromContent, linearToNestedHeadingList } from './utils';
/**
 * Table of Contents block edit component.
 *
 * @param {Object}                       props            The props.
 * @param {Object}                       props.attributes The block attributes.
 * @param {boolean}                      props.attributes.onlyIncludeCurrentPage
 * Whether to only include headings from the current page (if the post is
 * paginated).
 * @param {string}                       props.clientId
 * @param {(attributes: Object) => void} props.setAttributes
 *
 * @return {WPComponent} The component.
 */

export default function TableOfContentsEdit(_ref) {
  var onlyIncludeCurrentPage = _ref.attributes.onlyIncludeCurrentPage,
      clientId = _ref.clientId,
      setAttributes = _ref.setAttributes;
  var blockProps = useBlockProps(); // Local state; not saved to block attributes. The saved block is dynamic and uses PHP to generate its content.

  var _useState = useState([]),
      _useState2 = _slicedToArray(_useState, 2),
      headings = _useState2[0],
      setHeadings = _useState2[1];

  var _useState3 = useState([]),
      _useState4 = _slicedToArray(_useState3, 2),
      headingTree = _useState4[0],
      setHeadingTree = _useState4[1];

  var _useSelect = useSelect(function (select) {
    return {
      listBlockExists: !!select(blocksStore).getBlockType('core/list'),
      postContent: select(editorStore).getEditedPostContent()
    };
  }, []),
      listBlockExists = _useSelect.listBlockExists,
      postContent = _useSelect.postContent; // The page this block would be part of on the front-end. For performance
  // reasons, this is only calculated when onlyIncludeCurrentPage is true.


  var pageIndex = useSelect(function (select) {
    if (!onlyIncludeCurrentPage) {
      return null;
    }

    var _select = select(blockEditorStore),
        getBlockAttributes = _select.getBlockAttributes,
        getBlockIndex = _select.getBlockIndex,
        getBlockName = _select.getBlockName,
        getBlockOrder = _select.getBlockOrder;

    var blockIndex = getBlockIndex(clientId);
    var blockOrder = getBlockOrder(); // Calculate which page the block will appear in on the front-end by
    // counting how many <!--nextpage--> tags precede it.
    // Unfortunately, this implementation only accounts for Page Break and
    // Classic blocks, so if there are any <!--nextpage--> tags in any
    // other block, they won't be counted. This will result in the table
    // of contents showing headings from the wrong page if
    // onlyIncludeCurrentPage === true. Thankfully, this issue only
    // affects the editor implementation.

    var page = 1;

    for (var i = 0; i < blockIndex; i++) {
      var blockName = getBlockName(blockOrder[i]);

      if (blockName === 'core/nextpage') {
        page++;
      } else if (blockName === 'core/freeform') {
        var _getBlockAttributes$c;

        // Count the page breaks inside the Classic block.
        var pageBreaks = (_getBlockAttributes$c = getBlockAttributes(blockOrder[i]).content) === null || _getBlockAttributes$c === void 0 ? void 0 : _getBlockAttributes$c.match(/<!--nextpage-->/g);

        if (pageBreaks !== null && pageBreaks !== undefined) {
          page += pageBreaks.length;
        }
      }
    }

    return page;
  }, [clientId, onlyIncludeCurrentPage]);
  useEffect(function () {
    var latestHeadings;

    if (onlyIncludeCurrentPage) {
      var pagesOfContent = postContent.split('<!--nextpage-->');
      latestHeadings = getHeadingsFromContent(pagesOfContent[pageIndex - 1]);
    } else {
      latestHeadings = getHeadingsFromContent(postContent);
    }

    if (!isEqual(headings, latestHeadings)) {
      setHeadings(latestHeadings);
      setHeadingTree(linearToNestedHeadingList(latestHeadings));
    }
  }, [pageIndex, postContent, onlyIncludeCurrentPage]);

  var _useDispatch = useDispatch(blockEditorStore),
      replaceBlocks = _useDispatch.replaceBlocks;

  var toolbarControls = listBlockExists && createElement(BlockControls, null, createElement(ToolbarGroup, null, createElement(ToolbarButton, {
    onClick: function onClick() {
      return replaceBlocks(clientId, createBlock('core/list', {
        values: renderToString(createElement(TableOfContentsList, {
          nestedHeadingList: headingTree
        }))
      }));
    }
  }, __('Convert to static list'))));
  var inspectorControls = createElement(InspectorControls, null, createElement(PanelBody, {
    title: __('Table of Contents settings')
  }, createElement(ToggleControl, {
    label: __('Only include current page'),
    checked: onlyIncludeCurrentPage,
    onChange: function onChange(value) {
      return setAttributes({
        onlyIncludeCurrentPage: value
      });
    },
    help: onlyIncludeCurrentPage ? __('Only including headings from the current page (if the post is paginated).') : __('Toggle to only include headings from the current page (if the post is paginated).')
  }))); // If there are no headings or the only heading is empty.
  // Note that the toolbar controls are intentionally omitted since the
  // "Convert to static list" option is useless to the placeholder state.

  if (headings.length === 0) {
    return createElement(Fragment, null, createElement("div", blockProps, createElement(Placeholder, {
      icon: createElement(BlockIcon, {
        icon: "list-view"
      }),
      label: "Table of Contents",
      instructions: __('Start adding Heading blocks to create a table of contents. Headings with HTML anchors will be linked here.')
    })), inspectorControls);
  }

  return createElement(Fragment, null, createElement("nav", blockProps, createElement("ul", null, createElement(TableOfContentsList, {
    nestedHeadingList: headingTree
  }))), toolbarControls, inspectorControls);
}
//# sourceMappingURL=edit.js.map