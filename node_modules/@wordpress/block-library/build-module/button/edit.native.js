import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";

var _styles$button, _styles$button2, _styles$button3;

import { createElement, Fragment } from "@wordpress/element";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * External dependencies
 */
import { View, AccessibilityInfo, Platform, Text } from 'react-native';
/**
 * WordPress dependencies
 */

import { withInstanceId, compose } from '@wordpress/compose';
import { __ } from '@wordpress/i18n';
import { RichText, InspectorControls, BlockControls, withGradient, store as blockEditorStore, getColorObjectByAttributeValues, getGradientValueBySlug, __experimentalGetColorClassesAndStyles as getColorClassesAndStyles } from '@wordpress/block-editor';
import { PanelBody, RangeControl, ToolbarGroup, ToolbarButton, LinkSettingsNavigation, BottomSheetSelectControl } from '@wordpress/components';
import { Component } from '@wordpress/element';
import { withSelect, withDispatch } from '@wordpress/data';
import { link } from '@wordpress/icons';
/**
 * Internal dependencies
 */

import richTextStyle from './rich-text.scss';
import styles from './editor.scss';
import ColorBackground from './color-background';
import ColorEdit from './color-edit';
var MIN_BORDER_RADIUS_VALUE = 0;
var MAX_BORDER_RADIUS_VALUE = 50;
var INITIAL_MAX_WIDTH = 108;
var MIN_WIDTH = 40; // Map of the percentage width to pixel subtraction that make the buttons fit nicely into columns.

var MIN_WIDTH_MARGINS = {
  100: 0,
  75: (_styles$button = styles.button75) === null || _styles$button === void 0 ? void 0 : _styles$button.marginLeft,
  50: (_styles$button2 = styles.button50) === null || _styles$button2 === void 0 ? void 0 : _styles$button2.marginLeft,
  25: (_styles$button3 = styles.button25) === null || _styles$button3 === void 0 ? void 0 : _styles$button3.marginLeft
};

function WidthPanel(_ref) {
  var selectedWidth = _ref.selectedWidth,
      setAttributes = _ref.setAttributes;

  function handleChange(newWidth) {
    // Check if we are toggling the width off
    var width = selectedWidth === newWidth ? undefined : newWidth;

    if (newWidth === 'auto') {
      width = undefined;
    } // Update attributes


    setAttributes({
      width: width
    });
  }

  var options = [{
    value: 'auto',
    label: __('Auto')
  }, {
    value: 25,
    label: '25%'
  }, {
    value: 50,
    label: '50%'
  }, {
    value: 75,
    label: '75%'
  }, {
    value: 100,
    label: '100%'
  }];

  if (!selectedWidth) {
    selectedWidth = 'auto';
  }

  return createElement(PanelBody, {
    title: __('Width Settings')
  }, createElement(BottomSheetSelectControl, {
    label: __('Button width'),
    value: selectedWidth,
    onChange: handleChange,
    options: options
  }));
}

var ButtonEdit = /*#__PURE__*/function (_Component) {
  _inherits(ButtonEdit, _Component);

  var _super = _createSuper(ButtonEdit);

  function ButtonEdit(props) {
    var _this;

    _classCallCheck(this, ButtonEdit);

    _this = _super.call(this, props);
    _this.onChangeText = _this.onChangeText.bind(_assertThisInitialized(_this));
    _this.onChangeBorderRadius = _this.onChangeBorderRadius.bind(_assertThisInitialized(_this));
    _this.onClearSettings = _this.onClearSettings.bind(_assertThisInitialized(_this));
    _this.onLayout = _this.onLayout.bind(_assertThisInitialized(_this));
    _this.onSetMaxWidth = _this.onSetMaxWidth.bind(_assertThisInitialized(_this));
    _this.dismissSheet = _this.dismissSheet.bind(_assertThisInitialized(_this));
    _this.onShowLinkSettings = _this.onShowLinkSettings.bind(_assertThisInitialized(_this));
    _this.onHideLinkSettings = _this.onHideLinkSettings.bind(_assertThisInitialized(_this));
    _this.onToggleButtonFocus = _this.onToggleButtonFocus.bind(_assertThisInitialized(_this));
    _this.onPlaceholderTextWidth = _this.onPlaceholderTextWidth.bind(_assertThisInitialized(_this));
    _this.setRef = _this.setRef.bind(_assertThisInitialized(_this));
    _this.onRemove = _this.onRemove.bind(_assertThisInitialized(_this));
    _this.getPlaceholderWidth = _this.getPlaceholderWidth.bind(_assertThisInitialized(_this));
    _this.state = {
      maxWidth: INITIAL_MAX_WIDTH,
      isLinkSheetVisible: false,
      isButtonFocused: true,
      placeholderTextWidth: 0
    };
    _this.linkSettingsActions = [{
      label: __('Remove link'),
      onPress: _this.onClearSettings
    }];
    _this.linkSettingsOptions = {
      url: {
        label: __('Button Link URL'),
        placeholder: __('Add URL'),
        autoFocus: true,
        autoFill: true
      },
      openInNewTab: {
        label: __('Open in new tab')
      },
      linkRel: {
        label: __('Link Rel'),
        placeholder: __('None')
      }
    };
    _this.noFocusLinkSettingOptions = _objectSpread(_objectSpread({}, _this.linkSettingsOptions), {}, {
      url: _objectSpread(_objectSpread({}, _this.linkSettingsOptions.url), {}, {
        autoFocus: false
      })
    });
    return _this;
  }

  _createClass(ButtonEdit, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.onSetMaxWidth();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      var _this2 = this;

      var _this$props = this.props,
          isSelected = _this$props.isSelected,
          editorSidebarOpened = _this$props.editorSidebarOpened,
          parentWidth = _this$props.parentWidth;
      var _this$state = this.state,
          isLinkSheetVisible = _this$state.isLinkSheetVisible,
          isButtonFocused = _this$state.isButtonFocused;

      if (isSelected && !prevProps.isSelected) {
        this.onToggleButtonFocus(true);
      }

      if (prevProps.parentWidth !== parentWidth) {
        this.onSetMaxWidth(null, true);
      } // Blur `RichText` on Android when link settings sheet or button settings sheet is opened,
      // to avoid flashing caret after closing one of them


      if (!prevProps.editorSidebarOpened && editorSidebarOpened || !prevState.isLinkSheetVisible && isLinkSheetVisible) {
        if (Platform.OS === 'android' && this.richTextRef) {
          this.richTextRef.blur();
          this.onToggleButtonFocus(false);
        }
      }

      if (this.richTextRef) {
        if (!isSelected && isButtonFocused) {
          this.onToggleButtonFocus(false);
        }

        if (isSelected && !isButtonFocused) {
          AccessibilityInfo.isScreenReaderEnabled().then(function (enabled) {
            if (enabled) {
              _this2.onToggleButtonFocus(true);

              _this2.richTextRef.focus();
            }
          });
        }
      }
    }
  }, {
    key: "getBackgroundColor",
    value: function getBackgroundColor() {
      var _colorProps$style, _colorProps$style2;

      var _this$props2 = this.props,
          attributes = _this$props2.attributes,
          colors = _this$props2.colors,
          gradients = _this$props2.gradients;
      var backgroundColor = attributes.backgroundColor,
          gradient = attributes.gradient; // Return named gradient value if available.

      var gradientValue = getGradientValueBySlug(gradients, gradient);

      if (gradientValue) {
        return gradientValue;
      }

      var colorProps = getColorClassesAndStyles(attributes); // Retrieve named color object to force inline styles for themes that
      // do not load their color stylesheets in the editor.

      var colorObject = getColorObjectByAttributeValues(colors, backgroundColor);
      return (colorObject === null || colorObject === void 0 ? void 0 : colorObject.color) || ((_colorProps$style = colorProps.style) === null || _colorProps$style === void 0 ? void 0 : _colorProps$style.backgroundColor) || ((_colorProps$style2 = colorProps.style) === null || _colorProps$style2 === void 0 ? void 0 : _colorProps$style2.background) || styles.defaultButton.backgroundColor;
    }
  }, {
    key: "getTextColor",
    value: function getTextColor() {
      var _colorProps$style3;

      var _this$props3 = this.props,
          attributes = _this$props3.attributes,
          colors = _this$props3.colors;
      var colorProps = getColorClassesAndStyles(attributes); // Retrieve named color object to force inline styles for themes that
      // do not load their color stylesheets in the editor.

      var colorObject = getColorObjectByAttributeValues(colors, attributes.textColor);
      return (colorObject === null || colorObject === void 0 ? void 0 : colorObject.color) || ((_colorProps$style3 = colorProps.style) === null || _colorProps$style3 === void 0 ? void 0 : _colorProps$style3.color) || styles.defaultButton.color;
    }
  }, {
    key: "onChangeText",
    value: function onChangeText(value) {
      var setAttributes = this.props.setAttributes;
      setAttributes({
        text: value
      });
    }
  }, {
    key: "onChangeBorderRadius",
    value: function onChangeBorderRadius(value) {
      var setAttributes = this.props.setAttributes;
      setAttributes({
        borderRadius: value
      });
    }
  }, {
    key: "onShowLinkSettings",
    value: function onShowLinkSettings() {
      this.setState({
        isLinkSheetVisible: true
      });
    }
  }, {
    key: "onHideLinkSettings",
    value: function onHideLinkSettings() {
      this.setState({
        isLinkSheetVisible: false
      });
    }
  }, {
    key: "onToggleButtonFocus",
    value: function onToggleButtonFocus(value) {
      if (value !== this.state.isButtonFocused) {
        this.setState({
          isButtonFocused: value
        });
      }
    }
  }, {
    key: "onClearSettings",
    value: function onClearSettings() {
      var setAttributes = this.props.setAttributes;
      setAttributes({
        url: '',
        rel: '',
        linkTarget: ''
      });
      this.onHideLinkSettings();
    }
  }, {
    key: "onLayout",
    value: function onLayout(_ref2) {
      var nativeEvent = _ref2.nativeEvent;
      var width = nativeEvent.layout.width;
      this.onSetMaxWidth(width);
    }
  }, {
    key: "onSetMaxWidth",
    value: function onSetMaxWidth(width) {
      var isParentWidthDidChange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var maxWidth = this.state.maxWidth;
      var parentWidth = this.props.parentWidth;
      var spacing = styles.defaultButton.marginRight;
      var isParentWidthChanged = isParentWidthDidChange ? isParentWidthDidChange : maxWidth !== parentWidth;
      var isWidthChanged = maxWidth !== width;

      if (parentWidth && !width && isParentWidthChanged) {
        this.setState({
          maxWidth: parentWidth - spacing
        });
      } else if (!parentWidth && width && isWidthChanged) {
        this.setState({
          maxWidth: width - spacing
        });
      }
    }
  }, {
    key: "onRemove",
    value: function onRemove() {
      var _this$props4 = this.props,
          numOfButtons = _this$props4.numOfButtons,
          onDeleteBlock = _this$props4.onDeleteBlock,
          onReplace = _this$props4.onReplace;

      if (numOfButtons === 1) {
        onDeleteBlock();
      } else {
        onReplace([]);
      }
    }
  }, {
    key: "dismissSheet",
    value: function dismissSheet() {
      this.onHideLinkSettings();
      this.props.closeSettingsBottomSheet();
    }
  }, {
    key: "getLinkSettings",
    value: function getLinkSettings(isCompatibleWithSettings) {
      var isLinkSheetVisible = this.state.isLinkSheetVisible;
      var _this$props5 = this.props,
          attributes = _this$props5.attributes,
          setAttributes = _this$props5.setAttributes;
      return createElement(LinkSettingsNavigation, {
        isVisible: isLinkSheetVisible,
        url: attributes.url,
        rel: attributes.rel,
        linkTarget: attributes.linkTarget,
        onClose: this.dismissSheet,
        setAttributes: setAttributes,
        withBottomSheet: !isCompatibleWithSettings,
        hasPicker: true,
        actions: this.linkSettingsActions,
        options: isCompatibleWithSettings ? this.linkSettingsOptions : this.noFocusLinkSettingOptions,
        showIcon: !isCompatibleWithSettings
      });
    }
  }, {
    key: "setRef",
    value: function setRef(richText) {
      this.richTextRef = richText;
    } // Render `Text` with `placeholderText` styled as a placeholder
    // to calculate its width which then is set as a `minWidth`

  }, {
    key: "getPlaceholderWidth",
    value: function getPlaceholderWidth(placeholderText) {
      return createElement(Text, {
        style: styles.placeholder,
        onTextLayout: this.onPlaceholderTextWidth
      }, placeholderText);
    }
  }, {
    key: "onPlaceholderTextWidth",
    value: function onPlaceholderTextWidth(_ref3) {
      var nativeEvent = _ref3.nativeEvent;
      var _this$state2 = this.state,
          maxWidth = _this$state2.maxWidth,
          placeholderTextWidth = _this$state2.placeholderTextWidth;
      var textWidth = nativeEvent.lines[0] && nativeEvent.lines[0].width;

      if (textWidth && textWidth !== placeholderTextWidth) {
        this.setState({
          placeholderTextWidth: Math.min(textWidth, maxWidth)
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var _this$props6 = this.props,
          attributes = _this$props6.attributes,
          isSelected = _this$props6.isSelected,
          clientId = _this$props6.clientId,
          onReplace = _this$props6.onReplace,
          mergeBlocks = _this$props6.mergeBlocks,
          parentWidth = _this$props6.parentWidth,
          setAttributes = _this$props6.setAttributes;
      var placeholder = attributes.placeholder,
          text = attributes.text,
          borderRadius = attributes.borderRadius,
          url = attributes.url,
          _attributes$align = attributes.align,
          align = _attributes$align === void 0 ? 'center' : _attributes$align,
          width = attributes.width;
      var _this$state3 = this.state,
          maxWidth = _this$state3.maxWidth,
          isButtonFocused = _this$state3.isButtonFocused,
          placeholderTextWidth = _this$state3.placeholderTextWidth;
      var _styles$defaultButton = styles.defaultButton,
          spacing = _styles$defaultButton.paddingTop,
          borderWidth = _styles$defaultButton.borderWidth;

      if (parentWidth === 0) {
        return null;
      }

      var borderRadiusValue = Number.isInteger(borderRadius) ? borderRadius : styles.defaultButton.borderRadius;
      var outlineBorderRadius = borderRadiusValue > 0 ? borderRadiusValue + spacing + borderWidth : 0; // To achieve proper expanding and shrinking `RichText` on iOS, there is a need to set a `minWidth`
      // value at least on 1 when `RichText` is focused or when is not focused, but `RichText` value is
      // different than empty string.

      var minWidth = isButtonFocused || !isButtonFocused && text && text !== '' ? MIN_WIDTH : placeholderTextWidth;

      if (width) {
        // Set the width of the button.
        minWidth = Math.floor(maxWidth * (width / 100) - MIN_WIDTH_MARGINS[width]);
      } // To achieve proper expanding and shrinking `RichText` on Android, there is a need to set
      // a `placeholder` as an empty string when `RichText` is focused,
      // because `AztecView` is calculating a `minWidth` based on placeholder text.


      var placeholderText = isButtonFocused || !isButtonFocused && text && text !== '' ? '' : placeholder || __('Add textâ€¦');
      var backgroundColor = this.getBackgroundColor();
      var textColor = this.getTextColor();
      var isFixedWidth = !!width;
      return createElement(View, {
        onLayout: this.onLayout
      }, this.getPlaceholderWidth(placeholderText), createElement(ColorBackground, {
        borderRadiusValue: borderRadiusValue,
        backgroundColor: backgroundColor,
        isSelected: isSelected
      }, isSelected && createElement(View, {
        pointerEvents: "none",
        style: [styles.outline, {
          borderRadius: outlineBorderRadius,
          borderColor: backgroundColor
        }]
      }), createElement(RichText, {
        setRef: this.setRef,
        placeholder: placeholderText,
        value: text,
        onChange: this.onChangeText,
        style: _objectSpread(_objectSpread({}, richTextStyle.richText), {}, {
          paddingLeft: isFixedWidth ? 0 : richTextStyle.richText.paddingLeft,
          paddingRight: isFixedWidth ? 0 : richTextStyle.richText.paddingRight,
          color: textColor
        }),
        textAlign: align,
        placeholderTextColor: styles.placeholderTextColor.color,
        identifier: "text",
        tagName: "p",
        minWidth: minWidth // The minimum Button size.
        ,
        maxWidth: isFixedWidth ? minWidth : maxWidth // The width of the screen.
        ,
        id: clientId,
        isSelected: isButtonFocused,
        withoutInteractiveFormatting: true,
        unstableOnFocus: function unstableOnFocus() {
          return _this3.onToggleButtonFocus(true);
        },
        __unstableMobileNoFocusOnMount: !isSelected,
        selectionColor: textColor,
        onBlur: function onBlur() {
          _this3.onSetMaxWidth();
        },
        onReplace: onReplace,
        onRemove: this.onRemove,
        onMerge: mergeBlocks
      })), isSelected && createElement(Fragment, null, createElement(BlockControls, null, createElement(ToolbarGroup, null, createElement(ToolbarButton, {
        title: __('Edit link'),
        icon: link,
        onClick: this.onShowLinkSettings,
        isActive: url
      }))), this.getLinkSettings(false), createElement(ColorEdit, this.props), createElement(InspectorControls, null, createElement(PanelBody, {
        title: __('Border Settings')
      }, createElement(RangeControl, {
        label: __('Border Radius'),
        minimumValue: MIN_BORDER_RADIUS_VALUE,
        maximumValue: MAX_BORDER_RADIUS_VALUE,
        value: borderRadiusValue,
        onChange: this.onChangeBorderRadius
      })), createElement(WidthPanel, {
        selectedWidth: width,
        setAttributes: setAttributes
      }), createElement(PanelBody, {
        title: __('Link Settings')
      }, this.getLinkSettings(true)))));
    }
  }]);

  return ButtonEdit;
}(Component);

export default compose([withInstanceId, withGradient, withSelect(function (select, _ref4) {
  var clientId = _ref4.clientId,
      isSelected = _ref4.isSelected;

  var _select = select('core/edit-post'),
      isEditorSidebarOpened = _select.isEditorSidebarOpened;

  var _select2 = select(blockEditorStore),
      getBlockCount = _select2.getBlockCount,
      getBlockRootClientId = _select2.getBlockRootClientId,
      getSettings = _select2.getSettings;

  var parentId = getBlockRootClientId(clientId);
  var numOfButtons = getBlockCount(parentId);
  var settings = getSettings();
  return {
    colors: (settings === null || settings === void 0 ? void 0 : settings.colors) || [],
    gradients: (settings === null || settings === void 0 ? void 0 : settings.gradients) || [],
    editorSidebarOpened: isSelected && isEditorSidebarOpened(),
    numOfButtons: numOfButtons
  };
}), withDispatch(function (dispatch) {
  return {
    closeSettingsBottomSheet: function closeSettingsBottomSheet() {
      dispatch('core/edit-post').closeGeneralSidebar();
    }
  };
})])(ButtonEdit);
//# sourceMappingURL=edit.native.js.map