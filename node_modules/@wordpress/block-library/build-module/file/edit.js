import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { createElement, Fragment } from "@wordpress/element";

/**
 * External dependencies
 */
import classnames from 'classnames';
/**
 * WordPress dependencies
 */

import { getBlobByURL, isBlobURL, revokeBlobURL } from '@wordpress/blob';
import { __unstableGetAnimateClassName as getAnimateClassName, withNotices, ResizableBox, ToolbarButton } from '@wordpress/components';
import { useSelect, useDispatch } from '@wordpress/data';
import { BlockControls, BlockIcon, MediaPlaceholder, MediaReplaceFlow, RichText, useBlockProps, store as blockEditorStore } from '@wordpress/block-editor';
import { useEffect, useState } from '@wordpress/element';
import { useCopyToClipboard } from '@wordpress/compose';
import { __, _x } from '@wordpress/i18n';
import { file as icon } from '@wordpress/icons';
import { store as coreStore } from '@wordpress/core-data';
import { store as noticesStore } from '@wordpress/notices';
/**
 * Internal dependencies
 */

import FileBlockInspector from './inspector';
import { browserSupportsPdfs } from './utils';
export var MIN_PREVIEW_HEIGHT = 200;
export var MAX_PREVIEW_HEIGHT = 2000;

function ClipboardToolbarButton(_ref) {
  var text = _ref.text,
      disabled = _ref.disabled;

  var _useDispatch = useDispatch(noticesStore),
      createNotice = _useDispatch.createNotice;

  var ref = useCopyToClipboard(text, function () {
    createNotice('info', __('Copied URL to clipboard.'), {
      isDismissible: true,
      type: 'snackbar'
    });
  });
  return createElement(ToolbarButton, {
    className: "components-clipboard-toolbar-button",
    ref: ref,
    disabled: disabled
  }, __('Copy URL'));
}

function FileEdit(_ref2) {
  var attributes = _ref2.attributes,
      isSelected = _ref2.isSelected,
      setAttributes = _ref2.setAttributes,
      noticeUI = _ref2.noticeUI,
      noticeOperations = _ref2.noticeOperations;
  var id = attributes.id,
      fileName = attributes.fileName,
      href = attributes.href,
      textLinkHref = attributes.textLinkHref,
      textLinkTarget = attributes.textLinkTarget,
      showDownloadButton = attributes.showDownloadButton,
      downloadButtonText = attributes.downloadButtonText,
      displayPreview = attributes.displayPreview,
      previewHeight = attributes.previewHeight;

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      hasError = _useState2[0],
      setHasError = _useState2[1];

  var _useSelect = useSelect(function (select) {
    return {
      media: id === undefined ? undefined : select(coreStore).getMedia(id),
      mediaUpload: select(blockEditorStore).getSettings().mediaUpload
    };
  }, [id]),
      media = _useSelect.media,
      mediaUpload = _useSelect.mediaUpload;

  var _useDispatch2 = useDispatch(blockEditorStore),
      toggleSelection = _useDispatch2.toggleSelection;

  useEffect(function () {
    // Upload a file drag-and-dropped into the editor
    if (isBlobURL(href)) {
      var file = getBlobByURL(href);
      mediaUpload({
        filesList: [file],
        onFileChange: function onFileChange(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 1),
              newMedia = _ref4[0];

          return onSelectFile(newMedia);
        },
        onError: function onError(message) {
          setHasError(true);
          noticeOperations.createErrorNotice(message);
        }
      });
      revokeBlobURL(href);
    }

    if (downloadButtonText === undefined) {
      changeDownloadButtonText(_x('Download', 'button label'));
    }
  }, []);

  function onSelectFile(newMedia) {
    if (newMedia && newMedia.url) {
      setHasError(false);
      var isPdf = newMedia.url.endsWith('.pdf');
      setAttributes({
        href: newMedia.url,
        fileName: newMedia.title,
        textLinkHref: newMedia.url,
        id: newMedia.id,
        displayPreview: isPdf ? true : undefined,
        previewHeight: isPdf ? 600 : undefined
      });
    }
  }

  function onUploadError(message) {
    setHasError(true);
    noticeOperations.removeAllNotices();
    noticeOperations.createErrorNotice(message);
  }

  function changeLinkDestinationOption(newHref) {
    // Choose Media File or Attachment Page (when file is in Media Library)
    setAttributes({
      textLinkHref: newHref
    });
  }

  function changeOpenInNewWindow(newValue) {
    setAttributes({
      textLinkTarget: newValue ? '_blank' : false
    });
  }

  function changeShowDownloadButton(newValue) {
    setAttributes({
      showDownloadButton: newValue
    });
  }

  function changeDownloadButtonText(newValue) {
    // Remove anchor tags from button text content.
    setAttributes({
      downloadButtonText: newValue.replace(/<\/?a[^>]*>/g, '')
    });
  }

  function changeDisplayPreview(newValue) {
    setAttributes({
      displayPreview: newValue
    });
  }

  function handleOnResizeStop(event, direction, elt, delta) {
    toggleSelection(true);
    var newHeight = parseInt(previewHeight + delta.height, 10);
    setAttributes({
      previewHeight: newHeight
    });
  }

  function changePreviewHeight(newValue) {
    var newHeight = Math.max(parseInt(newValue, 10), MIN_PREVIEW_HEIGHT);
    setAttributes({
      previewHeight: newHeight
    });
  }

  var attachmentPage = media && media.link;
  var blockProps = useBlockProps({
    className: classnames(isBlobURL(href) && getAnimateClassName({
      type: 'loading'
    }), {
      'is-transient': isBlobURL(href)
    })
  });
  var displayPreviewInEditor = browserSupportsPdfs() && displayPreview;

  if (!href || hasError) {
    return createElement("div", blockProps, createElement(MediaPlaceholder, {
      icon: createElement(BlockIcon, {
        icon: icon
      }),
      labels: {
        title: __('File'),
        instructions: __('Upload a file or pick one from your media library.')
      },
      onSelect: onSelectFile,
      notices: noticeUI,
      onError: onUploadError,
      accept: "*"
    }));
  }

  return createElement(Fragment, null, createElement(FileBlockInspector, {
    hrefs: {
      href: href,
      textLinkHref: textLinkHref,
      attachmentPage: attachmentPage
    },
    openInNewWindow: !!textLinkTarget,
    showDownloadButton: showDownloadButton,
    changeLinkDestinationOption: changeLinkDestinationOption,
    changeOpenInNewWindow: changeOpenInNewWindow,
    changeShowDownloadButton: changeShowDownloadButton,
    displayPreview: displayPreview,
    changeDisplayPreview: changeDisplayPreview,
    previewHeight: previewHeight,
    changePreviewHeight: changePreviewHeight
  }), createElement(BlockControls, {
    group: "other"
  }, createElement(MediaReplaceFlow, {
    mediaId: id,
    mediaURL: href,
    accept: "*",
    onSelect: onSelectFile,
    onError: onUploadError
  }), createElement(ClipboardToolbarButton, {
    text: href,
    disabled: isBlobURL(href)
  })), createElement("div", blockProps, displayPreviewInEditor && createElement(ResizableBox, {
    size: {
      height: previewHeight
    },
    minHeight: MIN_PREVIEW_HEIGHT,
    maxHeight: MAX_PREVIEW_HEIGHT,
    minWidth: "100%",
    grid: [10, 10],
    enable: {
      top: false,
      right: false,
      bottom: true,
      left: false,
      topRight: false,
      bottomRight: false,
      bottomLeft: false,
      topLeft: false
    },
    onResizeStart: function onResizeStart() {
      return toggleSelection(false);
    },
    onResizeStop: handleOnResizeStop,
    showHandle: isSelected
  }, createElement("object", {
    className: "wp-block-file__preview",
    data: href,
    type: "application/pdf",
    "aria-label": __('Embed of the selected PDF file.')
  }), !isSelected && createElement("div", {
    className: "wp-block-file__preview-overlay"
  })), createElement("div", {
    className: 'wp-block-file__content-wrapper'
  }, createElement(RichText, {
    style: {
      display: 'inline-block'
    },
    tagName: "a" // must be block-level or else cursor disappears
    ,
    value: fileName,
    placeholder: __('Write file name…'),
    withoutInteractiveFormatting: true,
    onChange: function onChange(text) {
      return setAttributes({
        fileName: text
      });
    },
    href: textLinkHref
  }), showDownloadButton && createElement("div", {
    className: 'wp-block-file__button-richtext-wrapper'
  }, createElement(RichText, {
    tagName: "div" // must be block-level or else cursor disappears
    ,
    "aria-label": __('Download button text'),
    className: 'wp-block-file__button',
    value: downloadButtonText,
    withoutInteractiveFormatting: true,
    placeholder: __('Add text…'),
    onChange: function onChange(text) {
      return changeDownloadButtonText(text);
    }
  })))));
}

export default withNotices(FileEdit);
//# sourceMappingURL=edit.js.map