import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { createElement } from "@wordpress/element";

/**
 * WordPress dependencies
 */
import { useSelect } from '@wordpress/data';
import { BlockControls, useBlockProps, __experimentalUseNoRecursiveRenders as useNoRecursiveRenders, Warning, store as blockEditorStore } from '@wordpress/block-editor';
import { Dropdown, ToolbarGroup, ToolbarButton, Spinner } from '@wordpress/components';
import { __, sprintf } from '@wordpress/i18n';
import { store as coreStore } from '@wordpress/core-data';
/**
 * Internal dependencies
 */

import TemplatePartInnerBlocks from './inner-blocks';
import TemplatePartPlaceholder from './placeholder';
import TemplatePartSelection from './selection';
import { TemplatePartAdvancedControls } from './advanced-controls';
import { getTagBasedOnArea } from './get-tag-based-on-area';
export default function TemplatePartEdit(_ref) {
  var attributes = _ref.attributes,
      setAttributes = _ref.setAttributes,
      clientId = _ref.clientId;
  var slug = attributes.slug,
      theme = attributes.theme,
      tagName = attributes.tagName,
      _attributes$layout = attributes.layout,
      layout = _attributes$layout === void 0 ? {} : _attributes$layout;
  var templatePartId = theme && slug ? theme + '//' + slug : null;

  var _useNoRecursiveRender = useNoRecursiveRenders(templatePartId),
      _useNoRecursiveRender2 = _slicedToArray(_useNoRecursiveRender, 2),
      hasAlreadyRendered = _useNoRecursiveRender2[0],
      RecursionProvider = _useNoRecursiveRender2[1]; // Set the postId block attribute if it did not exist,
  // but wait until the inner blocks have loaded to allow
  // new edits to trigger this.


  var _useSelect = useSelect(function (select) {
    var _select = select(coreStore),
        getEditedEntityRecord = _select.getEditedEntityRecord,
        hasFinishedResolution = _select.hasFinishedResolution;

    var _select2 = select(blockEditorStore),
        getBlocks = _select2.getBlocks;

    var getEntityArgs = ['postType', 'wp_template_part', templatePartId];
    var entityRecord = templatePartId ? getEditedEntityRecord.apply(void 0, getEntityArgs) : null;
    var hasResolvedEntity = templatePartId ? hasFinishedResolution('getEditedEntityRecord', getEntityArgs) : false;
    return {
      innerBlocks: getBlocks(clientId),
      isResolved: hasResolvedEntity,
      isMissing: hasResolvedEntity && !entityRecord,
      area: entityRecord === null || entityRecord === void 0 ? void 0 : entityRecord.area
    };
  }, [templatePartId, clientId]),
      isResolved = _useSelect.isResolved,
      innerBlocks = _useSelect.innerBlocks,
      isMissing = _useSelect.isMissing,
      area = _useSelect.area;

  var blockProps = useBlockProps();
  var isPlaceholder = !slug;
  var isEntityAvailable = !isPlaceholder && !isMissing && isResolved;
  var TagName = tagName || getTagBasedOnArea(area); // We don't want to render a missing state if we have any inner blocks.
  // A new template part is automatically created if we have any inner blocks but no entity.

  if (innerBlocks.length === 0 && (slug && !theme || slug && isMissing)) {
    return createElement(TagName, blockProps, createElement(Warning, null, sprintf(
    /* translators: %s: Template part slug */
    __('Template part has been deleted or is unavailable: %s'), slug)));
  }

  if (isEntityAvailable && hasAlreadyRendered) {
    return createElement(TagName, blockProps, createElement(Warning, null, __('Block cannot be rendered inside itself.')));
  }

  return createElement(RecursionProvider, null, createElement(TemplatePartAdvancedControls, {
    tagName: tagName,
    setAttributes: setAttributes,
    isEntityAvailable: isEntityAvailable,
    templatePartId: templatePartId
  }), isPlaceholder && createElement(TagName, blockProps, createElement(TemplatePartPlaceholder, {
    area: attributes.area,
    setAttributes: setAttributes,
    innerBlocks: innerBlocks
  })), isEntityAvailable && createElement(BlockControls, null, createElement(ToolbarGroup, {
    className: "wp-block-template-part__block-control-group"
  }, createElement(Dropdown, {
    className: "wp-block-template-part__preview-dropdown-button",
    contentClassName: "wp-block-template-part__preview-dropdown-content",
    position: "bottom right left",
    renderToggle: function renderToggle(_ref2) {
      var isOpen = _ref2.isOpen,
          onToggle = _ref2.onToggle;
      return createElement(ToolbarButton, {
        "aria-expanded": isOpen,
        onClick: onToggle // Disable when open to prevent odd FireFox bug causing reopening.
        // As noted in https://github.com/WordPress/gutenberg/pull/24990#issuecomment-689094119 .
        ,
        disabled: isOpen
      }, __('Replace'));
    },
    renderContent: function renderContent(_ref3) {
      var onClose = _ref3.onClose;
      return createElement(TemplatePartSelection, {
        setAttributes: setAttributes,
        onClose: onClose
      });
    }
  }))), isEntityAvailable && createElement(TemplatePartInnerBlocks, {
    tagName: TagName,
    blockProps: blockProps,
    postId: templatePartId,
    hasInnerBlocks: innerBlocks.length > 0,
    layout: layout
  }), !isPlaceholder && !isResolved && createElement(TagName, blockProps, createElement(Spinner, null)));
}
//# sourceMappingURL=index.js.map