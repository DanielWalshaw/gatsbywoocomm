import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { createElement } from "@wordpress/element";
import _regeneratorRuntime from "@babel/runtime/regenerator";

/**
 * External dependencies
 */
import { debounce } from 'lodash';
/**
 * WordPress dependencies
 */

import { useDispatch } from '@wordpress/data';
import { store as noticesStore } from '@wordpress/notices';
import { __ } from '@wordpress/i18n';
import { useEffect, useRef, useState, useCallback, RawHTML } from '@wordpress/element';
import apiFetch from '@wordpress/api-fetch';
import { Button } from '@wordpress/components';
import { useInstanceId } from '@wordpress/compose';
export default function Form(_ref) {
  var id = _ref.id,
      idBase = _ref.idBase,
      instance = _ref.instance,
      setInstance = _ref.setInstance;

  var _useForm = useForm({
    id: id,
    idBase: idBase,
    instance: instance,
    setInstance: setInstance
  }),
      html = _useForm.html,
      setFormData = _useForm.setFormData;

  var setFormDataDebounced = useCallback(debounce(setFormData, 300), [setFormData]);
  return createElement(Control, {
    id: id,
    idBase: idBase,
    html: html,
    onChange: setFormDataDebounced,
    onSave: setFormData
  });
}

function useForm(_ref2) {
  var id = _ref2.id,
      idBase = _ref2.idBase,
      instance = _ref2.instance,
      setInstance = _ref2.setInstance;
  var isStillMounted = useRef(false);

  var _useState = useState(null),
      _useState2 = _slicedToArray(_useState, 2),
      html = _useState2[0],
      setHTML = _useState2[1];

  var _useState3 = useState(null),
      _useState4 = _slicedToArray(_useState3, 2),
      formData = _useState4[0],
      setFormData = _useState4[1];

  useEffect(function () {
    isStillMounted.current = true;
    return function () {
      return isStillMounted.current = false;
    };
  }, []);

  var _useDispatch = useDispatch(noticesStore),
      createNotice = _useDispatch.createNotice;

  useEffect(function () {
    var performFetch = /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var widget, _error$message, response, _error$message2;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!id) {
                  _context.next = 19;
                  break;
                }

                _context.prev = 1;

                if (!formData) {
                  _context.next = 8;
                  break;
                }

                _context.next = 5;
                return apiFetch({
                  path: "/wp/v2/widgets/".concat(id, "?context=edit"),
                  method: 'PUT',
                  data: {
                    form_data: formData
                  }
                });

              case 5:
                widget = _context.sent;
                _context.next = 11;
                break;

              case 8:
                _context.next = 10;
                return apiFetch({
                  path: "/wp/v2/widgets/".concat(id, "?context=edit"),
                  method: 'GET'
                });

              case 10:
                widget = _context.sent;

              case 11:
                if (isStillMounted.current) {
                  setHTML(widget.rendered_form);
                }

                _context.next = 17;
                break;

              case 14:
                _context.prev = 14;
                _context.t0 = _context["catch"](1);
                createNotice('error', (_error$message = _context.t0 === null || _context.t0 === void 0 ? void 0 : _context.t0.message) !== null && _error$message !== void 0 ? _error$message : __('An error occured while updating the widget.'));

              case 17:
                _context.next = 30;
                break;

              case 19:
                if (!idBase) {
                  _context.next = 30;
                  break;
                }

                _context.prev = 20;
                _context.next = 23;
                return apiFetch({
                  path: "/wp/v2/widget-types/".concat(idBase, "/encode"),
                  method: 'POST',
                  data: {
                    instance: instance,
                    form_data: formData
                  }
                });

              case 23:
                response = _context.sent;

                if (isStillMounted.current) {
                  setInstance(response.instance); // Only set HTML the first time so that we don't cause a
                  // focus loss by remounting the form.

                  setHTML(function (previousHTML) {
                    return previousHTML !== null && previousHTML !== void 0 ? previousHTML : response.form;
                  });
                }

                _context.next = 30;
                break;

              case 27:
                _context.prev = 27;
                _context.t1 = _context["catch"](20);
                createNotice('error', (_error$message2 = _context.t1 === null || _context.t1 === void 0 ? void 0 : _context.t1.message) !== null && _error$message2 !== void 0 ? _error$message2 : __('An error occured while updating the widget.'));

              case 30:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[1, 14], [20, 27]]);
      }));

      return function performFetch() {
        return _ref3.apply(this, arguments);
      };
    }();

    performFetch();
  }, [id, idBase, setInstance, formData // Do not trigger when `instance` changes so that we don't make two API
  // requests when there is form input.
  ]);
  return {
    html: html,
    setFormData: setFormData
  };
}

function Control(_ref4) {
  var id = _ref4.id,
      idBase = _ref4.idBase,
      html = _ref4.html,
      onChange = _ref4.onChange,
      onSave = _ref4.onSave;
  var controlRef = useRef();
  var formRef = useRef(); // Trigger 'widget-added' when widget is ready and 'widget-updated' when
  // widget changes. This event is what widgets' scripts use to initialize,
  // attach events, etc. The event must be fired using jQuery's event bus as
  // this is what widget scripts expect. If jQuery is not loaded, do nothing -
  // some widgets will still work regardless.

  var hasBeenAdded = useRef(false);
  useEffect(function () {
    if (!window.jQuery) {
      return;
    }

    var _window = window,
        $ = _window.jQuery;

    if (html) {
      $(document).trigger(hasBeenAdded.current ? 'widget-updated' : 'widget-added', [$(controlRef.current)]);
      hasBeenAdded.current = true;
    }
  }, [html, // Include id and idBase in the deps so that widget-updated is triggered
  // if they change.
  id, idBase]); // Prefer jQuery 'change' event instead of the native 'change' event because
  // many widgets use jQuery's event bus to trigger an update.

  useEffect(function () {
    var handler = function handler() {
      return onChange(serializeForm(formRef.current));
    };

    if (window.jQuery) {
      var _window2 = window,
          $ = _window2.jQuery;
      $(formRef.current).on('change', null, handler);
      return function () {
        return $(formRef.current).off('change', null, handler);
      };
    }

    formRef.current.addEventListener('change', handler);
    return function () {
      return formRef.current.removeEventListener('change', handler);
    };
  }, [onChange]); // Non-multi widgets can be saved via a Save button.

  var handleSubmit = function handleSubmit(event) {
    event.preventDefault();
    onSave(serializeForm(event.target));
  }; // We can't use the real widget number as this is calculated by the server
  // and we may not ever *actually* save this widget. Instead, use a fake but
  // unique number.


  var number = useInstanceId(Control);
  return createElement("div", {
    ref: controlRef,
    className: "widget open"
  }, createElement("div", {
    className: "widget-inside"
  }, createElement("form", {
    ref: formRef,
    className: "form",
    method: "post",
    onSubmit: handleSubmit
  }, createElement("input", {
    type: "hidden",
    name: "widget-id",
    className: "widget-id",
    value: id !== null && id !== void 0 ? id : "".concat(idBase, "-").concat(number)
  }), createElement("input", {
    type: "hidden",
    name: "id_base",
    className: "id_base",
    value: idBase !== null && idBase !== void 0 ? idBase : id
  }), createElement("input", {
    type: "hidden",
    name: "widget-width",
    className: "widget-width",
    value: "250"
  }), createElement("input", {
    type: "hidden",
    name: "widget-height",
    className: "widget-height",
    value: "200"
  }), createElement("input", {
    type: "hidden",
    name: "widget_number",
    className: "widget_number",
    value: idBase ? number : ''
  }), createElement("input", {
    type: "hidden",
    name: "add_new",
    className: "add_new",
    value: ""
  }), createElement(RawHTML, {
    className: "widget-content"
  }, html), id && createElement(Button, {
    type: "submit",
    isPrimary: true
  }, __('Save')))));
}

function serializeForm(form) {
  return new window.URLSearchParams(Array.from(new window.FormData(form))).toString();
}
//# sourceMappingURL=form.js.map