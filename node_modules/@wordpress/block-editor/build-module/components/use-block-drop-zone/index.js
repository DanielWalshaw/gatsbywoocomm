import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";

/**
 * WordPress dependencies
 */
import { useDispatch, useSelect } from '@wordpress/data';
import { useCallback, useState } from '@wordpress/element';
import { useThrottle, __experimentalUseDropZone as useDropZone } from '@wordpress/compose';
/**
 * Internal dependencies
 */

import useOnBlockDrop from '../use-on-block-drop';
import { getDistanceToNearestEdge } from '../../utils/math';
import { store as blockEditorStore } from '../../store';
/** @typedef {import('../../utils/math').WPPoint} WPPoint */

/**
 * The orientation of a block list.
 *
 * @typedef {'horizontal'|'vertical'|undefined} WPBlockListOrientation
 */

/**
 * Given a list of block DOM elements finds the index that a block should be dropped
 * at.
 *
 * @param {Element[]}              elements    Array of DOM elements that represent each block in a block list.
 * @param {WPPoint}                position    The position of the item being dragged.
 * @param {WPBlockListOrientation} orientation The orientation of a block list.
 *
 * @return {number|undefined} The block index that's closest to the drag position.
 */

export function getNearestBlockIndex(elements, position, orientation) {
  var allowedEdges = orientation === 'horizontal' ? ['left', 'right'] : ['top', 'bottom'];
  var candidateIndex;
  var candidateDistance;
  elements.forEach(function (element, index) {
    // Ensure the element is a block. It should have the `wp-block` class.
    if (!element.classList.contains('wp-block')) {
      return;
    }

    var rect = element.getBoundingClientRect();

    var _getDistanceToNearest = getDistanceToNearestEdge(position, rect, allowedEdges),
        _getDistanceToNearest2 = _slicedToArray(_getDistanceToNearest, 2),
        distance = _getDistanceToNearest2[0],
        edge = _getDistanceToNearest2[1];

    if (candidateDistance === undefined || distance < candidateDistance) {
      // If the user is dropping to the trailing edge of the block
      // add 1 to the index to represent dragging after.
      var isTrailingEdge = edge === 'bottom' || edge === 'right';
      var offset = isTrailingEdge ? 1 : 0; // If the target is the dragged block itself and another 1 to
      // index as the dragged block is set to `display: none` and
      // should be skipped in the calculation.

      var isTargetDraggedBlock = isTrailingEdge && elements[index + 1] && elements[index + 1].classList.contains('is-dragging');
      offset += isTargetDraggedBlock ? 1 : 0; // Update the currently known best candidate.

      candidateDistance = distance;
      candidateIndex = index + offset;
    }
  });
  return candidateIndex;
}
/**
 * @typedef  {Object} WPBlockDropZoneConfig
 * @property {string} rootClientId The root client id for the block list.
 */

/**
 * A React hook that can be used to make a block list handle drag and drop.
 *
 * @param {WPBlockDropZoneConfig} dropZoneConfig configuration data for the drop zone.
 */

export default function useBlockDropZone() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$rootClientId = _ref.rootClientId,
      targetRootClientId = _ref$rootClientId === void 0 ? '' : _ref$rootClientId;

  var _useState = useState(null),
      _useState2 = _slicedToArray(_useState, 2),
      targetBlockIndex = _useState2[0],
      setTargetBlockIndex = _useState2[1];

  var _useSelect = useSelect(function (select) {
    var _getBlockListSettings;

    var _select = select(blockEditorStore),
        getBlockListSettings = _select.getBlockListSettings,
        getTemplateLock = _select.getTemplateLock;

    return {
      isLockedAll: getTemplateLock(targetRootClientId) === 'all',
      orientation: (_getBlockListSettings = getBlockListSettings(targetRootClientId)) === null || _getBlockListSettings === void 0 ? void 0 : _getBlockListSettings.orientation
    };
  }, [targetRootClientId]),
      isLockedAll = _useSelect.isLockedAll,
      orientation = _useSelect.orientation;

  var _useDispatch = useDispatch('core/block-editor'),
      showInsertionPoint = _useDispatch.showInsertionPoint,
      hideInsertionPoint = _useDispatch.hideInsertionPoint;

  var onBlockDrop = useOnBlockDrop(targetRootClientId, targetBlockIndex);
  var throttled = useThrottle(useCallback(function (event, currentTarget) {
    var blockElements = Array.from(currentTarget.children);
    var targetIndex = getNearestBlockIndex(blockElements, {
      x: event.clientX,
      y: event.clientY
    }, orientation);
    setTargetBlockIndex(targetIndex === undefined ? 0 : targetIndex);

    if (targetIndex !== null) {
      showInsertionPoint(targetRootClientId, targetIndex);
    }
  }, []), 200);
  return useDropZone({
    isDisabled: isLockedAll,
    onDrop: onBlockDrop,
    onDragOver: function onDragOver(event) {
      // `currentTarget` is only available while the event is being
      // handled, so get it now and pass it to the thottled function.
      // https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget
      throttled(event, event.currentTarget);
    },
    onDragEnd: function onDragEnd() {
      throttled.cancel();
      hideInsertionPoint();
      setTargetBlockIndex(null);
    }
  });
}
//# sourceMappingURL=index.js.map