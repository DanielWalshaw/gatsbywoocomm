"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BorderColorEdit = BorderColorEdit;
exports.withBorderColorPaletteStyles = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classnames2 = _interopRequireDefault(require("classnames"));

var _hooks = require("@wordpress/hooks");

var _i18n = require("@wordpress/i18n");

var _compose = require("@wordpress/compose");

var _control = _interopRequireDefault(require("../components/colors-gradients/control"));

var _colors = require("../components/colors");

var _useEditorFeature = _interopRequireDefault(require("../components/use-editor-feature"));

var _border = require("./border");

var _utils = require("./utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Defining empty array here instead of inline avoids unnecessary re-renders of
// color control.
var EMPTY_ARRAY = [];
/**
 * Inspector control panel containing the border color related configuration.
 *
 * There is deliberate overlap between the colors and borders block supports
 * relating to border color. It can be argued the border color controls could
 * be included within either, or both, the colors and borders panels in the
 * inspector controls. If they share the same block attributes it should not
 * matter.
 *
 * @param  {Object} props Block properties.
 * @return {WPElement}    Border color edit element.
 */

function BorderColorEdit(props) {
  var _style$border;

  var _props$attributes = props.attributes,
      borderColor = _props$attributes.borderColor,
      style = _props$attributes.style,
      setAttributes = props.setAttributes;
  var colors = (0, _useEditorFeature.default)('color.palette') || EMPTY_ARRAY;
  var disableCustomColors = !(0, _useEditorFeature.default)('color.custom');
  var disableCustomGradients = !(0, _useEditorFeature.default)('color.customGradient');

  var onChangeColor = function onChangeColor(value) {
    var colorObject = (0, _colors.getColorObjectByColorValue)(colors, value);

    var newStyle = _objectSpread(_objectSpread({}, style), {}, {
      border: _objectSpread(_objectSpread({}, style === null || style === void 0 ? void 0 : style.border), {}, {
        color: colorObject !== null && colorObject !== void 0 && colorObject.slug ? undefined : value
      })
    }); // If empty slug, ensure undefined to remove attribute.


    var newNamedColor = colorObject !== null && colorObject !== void 0 && colorObject.slug ? colorObject.slug : undefined;
    setAttributes({
      style: (0, _utils.cleanEmptyObject)(newStyle),
      borderColor: newNamedColor
    });
  };

  return (0, _element.createElement)(_control.default, {
    label: (0, _i18n.__)('Border color'),
    value: borderColor || (style === null || style === void 0 ? void 0 : (_style$border = style.border) === null || _style$border === void 0 ? void 0 : _style$border.color),
    colors: colors,
    gradients: undefined,
    disableCustomColors: disableCustomColors,
    disableCustomGradients: disableCustomGradients,
    onColorChange: onChangeColor
  });
}
/**
 * Filters registered block settings, extending attributes to include
 * `borderColor` if needed.
 *
 * @param  {Object} settings Original block settings.
 * @return {Object}          Updated block settings.
 */


function addAttributes(settings) {
  if (!(0, _border.hasBorderSupport)(settings, 'color')) {
    return settings;
  } // Allow blocks to specify default value if needed.


  if (settings.attributes.borderColor) {
    return settings;
  } // Add new borderColor attribute to block settings.


  return _objectSpread(_objectSpread({}, settings), {}, {
    attributes: _objectSpread(_objectSpread({}, settings.attributes), {}, {
      borderColor: {
        type: 'string'
      }
    })
  });
}
/**
 * Override props assigned to save component to inject border color.
 *
 * @param  {Object} props      Additional props applied to save element.
 * @param  {Object} blockType  Block type definition.
 * @param  {Object} attributes Block's attributes
 * @return {Object}            Filtered props to apply to save element.
 */


function addSaveProps(props, blockType, attributes) {
  var _style$border2;

  if (!(0, _border.hasBorderSupport)(blockType, 'color') || (0, _border.shouldSkipSerialization)(blockType)) {
    return props;
  }

  var borderColor = attributes.borderColor,
      style = attributes.style;
  var borderColorClass = (0, _colors.getColorClassName)('border-color', borderColor);
  var newClassName = (0, _classnames2.default)(props.className, (0, _defineProperty2.default)({
    'has-border-color': borderColor || (style === null || style === void 0 ? void 0 : (_style$border2 = style.border) === null || _style$border2 === void 0 ? void 0 : _style$border2.color)
  }, borderColorClass, !!borderColorClass)); // If we are clearing the last of the previous classes in `className`
  // set it to `undefined` to avoid rendering empty DOM attributes.

  props.className = newClassName ? newClassName : undefined;
  return props;
}
/**
 * Filters the registered block settings to apply border color styles and
 * classnames to the block edit wrapper.
 *
 * @param {Object} settings Original block settings.
 * @return {Object}         Filtered block settings.
 */


function addEditProps(settings) {
  if (!(0, _border.hasBorderSupport)(settings, 'color') || (0, _border.shouldSkipSerialization)(settings)) {
    return settings;
  }

  var existingGetEditWrapperProps = settings.getEditWrapperProps;

  settings.getEditWrapperProps = function (attributes) {
    var props = {};

    if (existingGetEditWrapperProps) {
      props = existingGetEditWrapperProps(attributes);
    }

    return addSaveProps(props, settings, attributes);
  };

  return settings;
}
/**
 * This adds inline styles for color palette colors.
 * Ideally, this is not needed and themes should load their palettes on the editor.
 *
 * @param  {Function} BlockListBlock Original component
 * @return {Function}                Wrapped component
 */


var withBorderColorPaletteStyles = (0, _compose.createHigherOrderComponent)(function (BlockListBlock) {
  return function (props) {
    var _getColorObjectByAttr, _props$wrapperProps;

    var name = props.name,
        attributes = props.attributes;
    var borderColor = attributes.borderColor;
    var colors = (0, _useEditorFeature.default)('color.palette') || EMPTY_ARRAY;

    if (!(0, _border.hasBorderSupport)(name, 'color') || (0, _border.shouldSkipSerialization)(name)) {
      return (0, _element.createElement)(BlockListBlock, props);
    }

    var extraStyles = {
      borderColor: borderColor ? (_getColorObjectByAttr = (0, _colors.getColorObjectByAttributeValues)(colors, borderColor)) === null || _getColorObjectByAttr === void 0 ? void 0 : _getColorObjectByAttr.color : undefined
    };
    var wrapperProps = props.wrapperProps;
    wrapperProps = _objectSpread(_objectSpread({}, props.wrapperProps), {}, {
      style: _objectSpread(_objectSpread({}, extraStyles), (_props$wrapperProps = props.wrapperProps) === null || _props$wrapperProps === void 0 ? void 0 : _props$wrapperProps.style)
    });
    return (0, _element.createElement)(BlockListBlock, (0, _extends2.default)({}, props, {
      wrapperProps: wrapperProps
    }));
  };
});
exports.withBorderColorPaletteStyles = withBorderColorPaletteStyles;
(0, _hooks.addFilter)('blocks.registerBlockType', 'core/border/addAttributes', addAttributes);
(0, _hooks.addFilter)('blocks.getSaveContent.extraProps', 'core/border/addSaveProps', addSaveProps);
(0, _hooks.addFilter)('blocks.registerBlockType', 'core/border/addEditProps', addEditProps);
(0, _hooks.addFilter)('editor.BlockListBlock', 'core/border/with-border-color-palette-styles', withBorderColorPaletteStyles);
//# sourceMappingURL=border-color.js.map